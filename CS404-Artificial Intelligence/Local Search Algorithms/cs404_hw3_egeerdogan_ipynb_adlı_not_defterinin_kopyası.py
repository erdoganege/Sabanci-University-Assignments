# -*- coding: utf-8 -*-
"""CS404-Hw3-EgeErdogan.ipynb adlı not defterinin kopyası

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lJs5Qzqo_5HmjJ2Nnj0bewgCWO8A41ak

# NQuenn with Hill Climbing
"""

import time
import random
import numpy as np
from random import shuffle
from random import randrange
import math

def calculateNumberOfConflicts(position):
    """
    returns number of conflicts
    """
    numberOfConflicts = 0  # initialize as 0

    for i in range(0, len(position)):
        for j in range(i + 1, len(position)):
            if position[i] == position[j]:
                numberOfConflicts += 1  # increment if horizontal conflict
            elif abs(i - j) == abs(position[i] - position[j]):
                numberOfConflicts += 1  # increment if diagonal conflict

    return numberOfConflicts


def bestNeighbor(position):
    """
    returns the best neighbor - shd be best neighbor
    """
    # define current position's number of conflict as the min number of conflict
    min_numberOfConflicts = calculateNumberOfConflicts(position)

    # define best position as current position
    best_position = position
    for i in range(0, len(position)):
        for j in range(0, len(position)):
            if j != position[i]:
                temp = position.copy()
                temp[i] = j
                temp_numberOfConflicts = calculateNumberOfConflicts(temp)
                if temp_numberOfConflicts <= min_numberOfConflicts:
                    min_numberOfConflicts = temp_numberOfConflicts
                    best_position = temp
    return best_position

def randomNeighbor(position):
    """
    returns a random neighbor which is better than the current position
    """
    #add your solution
    min_numberOfConflicts = calculateNumberOfConflicts(position)
    best_positions = []
    for i in range(0, len(position)):
        for j in range(0, len(position)):
            if j != position[i]:
                temp = position.copy()
                temp[i] = j
                temp_numberOfConflicts = calculateNumberOfConflicts(temp)
                if temp_numberOfConflicts < min_numberOfConflicts:  #look for only better than current position
                    best_positions.append(temp) 
    if len(best_positions) == 0:
      return position
    else:
      return random.choice(best_positions)     

def printSolutionT(position):
    N = len(position)

    for i in range(N):
        row = ""
        for j in range(N):
            if position[i] == j:
                row += "X "
            else:
                row += "O "
        print(row)

def randomNeighbor2(position):
    """
    returns a random neighbor which is better than the current position
    """
    #add your solution
    best_positions = []
    for i in range(0, len(position)):
        for j in range(0, len(position)):
            if j != position[i]:
                temp = position.copy()
                temp[i] = j
                best_positions.append(temp) 
    return random.choice(best_positions)  

def SimulatedRandomNeighbor(position, T):
    while True:
      T = T - 0.5   #scheduler
      if T == 0:  #check if it is the end
        return  position
      if  calculateNumberOfConflicts(position) == 0:  #check if we found a solution
        return position
      next_position = randomNeighbor2(position)   #totally random neighbor
      E = calculateNumberOfConflicts(position) - calculateNumberOfConflicts(next_position)  #energy diff
      ratio = E/T
      prob = math.exp(ratio)
      random_prob = random.uniform(0,1)
      if E > 0:
        position = next_position
      else:
        if (prob <= random_prob):  #check probability for bad neighbor
          position = next_position
        else:
          pass

def NQueen(N, randomRestart=True, stochastic=False, upperBound=np.inf):
    if N in [2, 3]:
        raise ValueError("Failure, no solution exists for given N.")

    solved = False
    current_position = list(np.zeros(N))
    count = 0
    while (calculateNumberOfConflicts(current_position) > 0) and count < upperBound:
        # set an random initial position with N queen.
        # if position[k] = j, then there exist a queen at k,j
        # notice that this representation is indeed compact and suitable.
        initial_position = [randrange(N) for _ in range(N)]
        current_position = initial_position
        while True:        
            if stochastic:
                pass
                #add your solution
                neighbor = randomNeighbor(current_position)
            else:
                neighbor = bestNeighbor(current_position)

            if calculateNumberOfConflicts(neighbor) >= calculateNumberOfConflicts(current_position):
                if randomRestart:
                    break # if no better neighbour, initialize a random position
                else:
                    if calculateNumberOfConflicts(current_position) != 0:
                        print("Failure, no solution found.")
                        #printSolutionT(initial_position)
                        return solved
                    else:
                        printSolutionT(current_position)
                        return True
            
            # better placement is found, update current position
            current_position = neighbor 
        count += 1

    if randomRestart:
        print("restart count:", count)

    if count >= upperBound:
        print("Failure, no solution found.")
        #{printSolutionT(initial_position)}
    else:
        printSolutionT(current_position)
        solved = True

    return solved, count

N=10 # number of quenn
success = 0
start = time.time()
for i in range(100):
  x = NQueen(N, randomRestart=False)
  if (x):
    success = success + 1
end = time.time()
average_time = (end-start)/100

print("Number of successes: ", success)
print("Success Percentage: ", success / 100)
print("Average time: ", average_time)
print(f"Elapsed time: {end - start}.")

N=20 # number of quenn

success = 0
restart_count = 0
start = time.time()
for i in range(100):
  x = NQueen(N, randomRestart=False, stochastic=True)
  if x:
    success = success + 1
end = time.time()

average_time = (end-start)/100

print("Number of successes: ", success)
print("Success Percentage: ", success / 100)

print("Average time: ", average_time)
print(f"Elapsed time: {end - start}.")

N=10 # number of quenn

success = 0
restart_count = 0
start = time.time()
for i in range(100):
  x, temp = NQueen(N, randomRestart=True, upperBound=1000)
  if (x):
    success = success + 1
    restart_count = restart_count + temp
end = time.time()
average_time = (end-start)/100

print("Number of successes: ", success)
print("Success Percentage: ", success / 100)

print("Average number of restarts to find solution", restart_count / success)

print("Average time: ", average_time)
print(f"Elapsed time: {end - start}.")

def NQueen2(N, simulated=True, temp = 500):
    if N in [2, 3]:
        raise ValueError("Failure, no solution exists for given N.")

    current_position = list(np.zeros(N))    
    initial_position = [randrange(N) for _ in range(N)]
    current_position = initial_position
    current_position= SimulatedRandomNeighbor(current_position, temp)
    if calculateNumberOfConflicts(current_position) != 0:
        print("Failure, no solution found.") 
        return False
    else:
        printSolutionT(current_position)
        return True

N = 20
success = 0
start = time.time()
for i in range(100):
  x = NQueen2(N, simulated=True, temp=10000)
  if (x):
    success = success + 1
  
end = time.time()
average_time = (end-start)/100

print("Number of successes: ", success)
print("Success Percentage: ", success / 100)


print("Average time: ", average_time)
print(f"Elapsed time: {end - start}.")

